package twitterx.twitter.nitter

import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class RSSParserTest {

    private val parser = RSSParser()

    private fun loadXmlFixture(filename: String): String {
        return this::class.java.getResource("/$filename")?.readText()
            ?: throw IllegalArgumentException("Resource $filename not found")
    }

    @Test
    fun `parseRSSFeed parses successful RSS feed correctly`() {
        val rssXml = loadXmlFixture("successful_rss_feed.xml")

        val feed = parser.parseRSSFeed(rssXml)

        assertEquals("Elon Musk / @elonmusk", feed.title)
        assertEquals("Twitter feed for: @elonmusk. Generated by 127.0.0.1:8049", feed.description)
        assertEquals("http://127.0.0.1:8049/elonmusk", feed.link)
        assertEquals(3, feed.items.size)

        // Check first item
        val firstItem = feed.items[0]
        assertEquals("This is the way", firstItem.title)
        assertEquals("@elonmusk", firstItem.creator)
        assertEquals("http://127.0.0.1:8049/elonmusk/status/1933577050016940084#m", firstItem.link)
        assertEquals("http://127.0.0.1:8049/elonmusk/status/1933577050016940084#m", firstItem.guid)
        assertTrue(firstItem.content?.contains("This is the way") == true)
    }

    @Test
    fun `parseRSSFeed parses empty RSS feed correctly`() {
        val rssXml = loadXmlFixture("empty_rss_feed.xml")

        val feed = parser.parseRSSFeed(rssXml)

        assertEquals("Empty User / @emptyuser", feed.title)
        assertEquals("Twitter feed for: @emptyuser. Generated by 127.0.0.1:8049", feed.description)
        assertEquals("http://127.0.0.1:8049/emptyuser", feed.link)
        assertTrue(feed.items.isEmpty())
    }

    @Test
    fun `parseRSSFeed parses media RSS feed correctly`() {
        val rssXml = loadXmlFixture("media_rss_feed.xml")

        val feed = parser.parseRSSFeed(rssXml)

        assertEquals("Elon Musk / @elonmusk", feed.title)
        assertEquals(3, feed.items.size)

        // Check video item
        val videoItem = feed.items[0]
        assertEquals("Video", videoItem.title)
        assertEquals("@elonmusk", videoItem.creator)
        assertTrue(videoItem.content?.isEmpty() == true) // Empty content for video

        // Check reply with media
        val replyItem = feed.items[1]
        assertEquals("R to @elonmusk: How it started", replyItem.title)
        assertEquals("@elonmusk", replyItem.creator)
        assertTrue(replyItem.content?.contains("How it started") == true)

        // Check retweet with media
        val retweetItem = feed.items[2]
        assertEquals(
            "RT by @elonmusk: Timelapse of most recent Tunnel Boring Machine breakthrough in Las Vegas",
            retweetItem.title
        )
        assertEquals("@boringcompany", retweetItem.creator)
        assertTrue(retweetItem.content?.contains("Timelapse") == true)
    }

    @Test
    fun `parseRSSFeed handles malformed RSS gracefully`() {
        val malformedXml = loadXmlFixture("malformed_rss_feed.xml")

        val feed = parser.parseRSSFeed(malformedXml)

        assertEquals("Malformed User / @malformeduser", feed.title)
        assertEquals("Twitter feed for: @malformeduser. Generated by nitter.net", feed.description)
    }

    @Test
    fun `parseRSSFeed extracts CDATA content correctly`() {
        val rssXml = loadXmlFixture("successful_rss_feed.xml")

        val feed = parser.parseRSSFeed(rssXml)

        val firstItem = feed.items[0]
        // Should extract content from CDATA and clean HTML tags
        assertTrue(firstItem.content?.contains("This is the way") == true)
        // HTML tags should be cleaned
        assertTrue(!firstItem.content.contains("<a href"))
        assertTrue(!firstItem.content.contains("<p>"))
    }

    @Test
    fun `parseRSSFeed handles various date formats`() {
        val rssXml = loadXmlFixture("successful_rss_feed.xml")
        val feed = parser.parseRSSFeed(rssXml)
        assertTrue(feed.items.isNotEmpty())
    }

    @Test
    fun `parseRSSFeed handles HTML entities correctly`() {
        val rssWithEntities = """
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0">
              <channel>
                <title>Test &amp; Entities</title>
                <description>Test feed with entities</description>
                <link>https://example.com</link>
                <item>
                  <title>Tweet with &quot;quotes&quot; &amp; entities</title>
                  <description><![CDATA[<p>Content with &amp; entities &lt;test&gt;</p>]]></description>
                  <link>https://example.com/status/123</link>
                  <pubDate>Mon, 18 Jul 2022 09:35:58 +0000</pubDate>
                  <guid>https://example.com/status/123</guid>
                </item>
              </channel>
            </rss>
        """.trimIndent()

        val feed = parser.parseRSSFeed(rssWithEntities)

        assertEquals("Test &amp; Entities", feed.title)
        assertEquals(1, feed.items.size)

        val item = feed.items[0]
        assertEquals("Tweet with &quot;quotes&quot; &amp; entities", item.title)
        assertTrue(item.content?.contains("Content with & entities <test>") == true)
    }

    @Test
    fun `parseRSSFeed handles real example xml with diverse tweet types`() {
        val rssXml = loadXmlFixture("example.xml")

        val feed = parser.parseRSSFeed(rssXml)

        assertEquals("Elon Musk / @elonmusk", feed.title)
        assertTrue(feed.items.size >= 15) // Should have many real tweets

        // Check for different tweet types in real data
        val hasRegularTweet = feed.items.any { !it.title.startsWith("RT by") && !it.title.startsWith("R to") }
        val hasRetweet = feed.items.any { it.title.startsWith("RT by @elonmusk:") }
        val hasReply = feed.items.any { it.title.startsWith("R to @elonmusk:") }

        assertTrue(hasRegularTweet, "Should have regular tweets")
        assertTrue(hasRetweet, "Should have retweets")
        assertTrue(hasReply, "Should have replies")

        // Check tweet ID extraction works with real data
        val tweetIds = feed.items.mapNotNull { item ->
            val matcher = Regex("/status/([0-9]+)").find(item.link)
            matcher?.groupValues?.get(1)
        }

        assertTrue(tweetIds.isNotEmpty(), "Should extract tweet IDs")
        assertTrue(tweetIds.all { it.length >= 15 }, "Tweet IDs should be realistic length")
    }
}
